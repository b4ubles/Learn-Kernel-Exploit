#include <linux/module.h>
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/cdev.h>
#include <asm/uaccess.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/string.h>

#define GETTHREADINFO 0

struct ioctl_param
{
    size_t len;
    void* buf;
    void* addr;
};

// device number
int arw_major = 0;
int arw_minor = 0;
char* arw_name = "arw";
struct class *arw_class;
struct cdev cdev;

long arw_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static const struct file_operations arw_fops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = arw_ioctl,
    // linux 2.6.36内核之后unlocked_ioctl取代ioctl
};

long arw_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{

    struct ioctl_param  par;
    struct ioctl_param* p_arg;
    long   p_stack;
    struct thread_info* info;
    int retval;

    retval = 0;
    p_arg  = (struct ioctl_param*)arg;
    copy_from_user(&par, p_arg, sizeof(struct ioctl_param));
    
    switch (cmd) {
        case GETTHREADINFO:
            p_stack = (long) &retval;
            p_stack = p_stack & 0xffffffffffffc000;
            info    = (struct thread_info*)p_stack;
            printk("addr_limit's addr: 0x%p\n", &info->addr_limit);
            // 取消 addr limit
            memset(&info->addr_limit, 0xff, 0x8);
            // return thread_info's address
            put_user((void*)info, &p_arg->addr);
            break;
        default:
            retval = -1;
            break;
    }

    return retval;
}

static int arw_init(void)
{
    // device number
    dev_t devno = MKDEV(arw_major, arw_minor);
    int result;

    if (arw_major) {
        // 静态分配设备号
        result = register_chrdev_region(devno, 1, arw_name);
    } else {
        // 动态分配设备号，防止冲突
        result = alloc_chrdev_region(&devno, 0, 1, arw_name);
        arw_major = MAJOR(devno);
        arw_minor = MINOR(devno);
    }

    printk("major for /dev/arw: %d.%d\n", arw_major, arw_minor);

    if (result < 0) {
        printk("arw init fail with result %d\n", result);
        return result;
    }

    arw_class = class_create(THIS_MODULE, arw_name);
    device_create(arw_class, NULL, devno, NULL, arw_name);

    cdev_init(&cdev, &arw_fops);
    cdev.owner = THIS_MODULE;
    cdev_add(&cdev, devno, 1);
    printk("arw init success\n");
    return 0;
}

static void arw_exit(void)
{
    cdev_del(&cdev);
    device_destroy(arw_class, MKDEV(arw_major, arw_minor));
    class_destroy(arw_class);
    unregister_chrdev_region(MKDEV(arw_major, arw_minor), 1);
    printk("arw exit success\n");
}

MODULE_LICENSE("GPL");

module_init(arw_init);
module_exit(arw_exit);
